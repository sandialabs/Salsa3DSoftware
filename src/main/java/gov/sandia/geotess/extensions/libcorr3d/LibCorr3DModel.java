/**
 * Copyright 2009 Sandia Corporation. Under the terms of Contract
 * DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government
 * retains certain rights in this software.
 * 
 * BSD Open Source License.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *    * Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of Sandia National Laboratories nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
package gov.sandia.geotess.extensions.libcorr3d;

import java.io.BufferedInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Scanner;

import gov.sandia.geotess.Data;
import gov.sandia.geotess.GeoTessException;
import gov.sandia.geotess.GeoTessGrid;
import gov.sandia.geotess.GeoTessMetaData;
import gov.sandia.geotess.GeoTessModel;
import gov.sandia.geotess.GeoTessPosition;
import gov.sandia.geotess.GeoTessUtils;
import gov.sandia.geotess.PointMap;
import gov.sandia.geotess.Profile;
import gov.sandia.gmp.util.globals.DataType;
import gov.sandia.gmp.util.globals.GMTFormat;
import gov.sandia.gmp.util.globals.Globals;
import gov.sandia.gmp.util.globals.Site;
import gov.sandia.gmp.util.logmanager.ScreenWriterOutput;
import gov.sandia.gmp.util.numerical.vector.EarthShape;

/**
 * This is a LibCorr3D extension of the GeoTessModel for use by LibCorr3D.
 * Specific capabilities, beyond those of the base class, include acting as a
 * metadata container for various additional descriptive strings, and to provide
 * a home for the overloaded functions GeoTessModel::loadModelBinary(...) and
 * GeoTessModel::loadExtraData(...) binary read functions.
 * <p>This class can read libcorr2d surfaces generated by kbcit and convert 
 * them into libcorr3d models on-the-fly.
 */
public class LibCorr3DModel extends GeoTessModel
{
    
	private static int nextIndex;
	public final int index;
	
	/**
	 * Site information including name, lat, lon, depth, onTime and offTime.
	 */
	private Site site;

	/**
	 * Phase that this model supports.
	 */
	private String phase;
	
	/**
	 * Attribute that this model supports.
	 */
	private String parameters;
	private String comments;	
	private String baseModel;
	private String baseModelVersion;
	

	public final static int defaultFormatVersion = 2;
	
	private int formatVersion;
	

	/**
	 * List of phases supported by this model.
	 */
	private List<String> supportedPhases;
	
	/**
	 * The phase name extracted from the fileName.
	 * FileName is supposed to be:
	 * &lt;sta&gt;_&lt;phase&gt;_&lt;TT | AZ | SLO&gt;_&lt;ondate&gt;_&lt;offdate&gt;
	 * with no extension.
	 */
	protected String fileNamePhase;
	
	/**
	 * The attribute extracted from the fileName.
	 * FileName is supposed to be:
	 * &lt;sta&gt;_&lt;phase&gt;_&lt;TT | AZ | SLO&gt;_&lt;ondate&gt;_&lt;offdate&gt;
	 * with no extension, so fileNameAttribute should
	 * be one of TT | AZ | SLO
	 */
	protected String fileNameAttribute;
	
    /**
     * Classes that extend GeoTessModel must override this method
     * and populate their 'extra' data with shallow copies from the model 
     * specified in the parameter list.  
     * @param other the other model from which to copy extra data
     * @throws Exception 
     */
	@Override
	public void copyDerivedClassData(GeoTessModel other) throws Exception
	{
		super.copyDerivedClassData(other);
		this.site = ((LibCorr3DModel)other).site;    
		this.phase = ((LibCorr3DModel)other).phase;
		this.parameters = ((LibCorr3DModel)other).parameters;
		this.baseModel = ((LibCorr3DModel)other).baseModel;
		this.baseModelVersion = ((LibCorr3DModel)other).baseModelVersion;
		this.comments = ((LibCorr3DModel)other).comments;
		this.supportedPhases = ((LibCorr3DModel)other).supportedPhases;
		this.fileNamePhase = ((LibCorr3DModel)other).fileNamePhase;
		this.fileNameAttribute = ((LibCorr3DModel)other).fileNameAttribute;
	}

	protected LibCorr3DModel() 
	{
		super();
		index = nextIndex++;
	}
	
	public LibCorr3DModel(File inputFile, String relativeGridPath) throws IOException
	{
		super(inputFile, relativeGridPath);
		index = nextIndex++;
	}
	
	public LibCorr3DModel(File inputFile) throws IOException
	{
		super(inputFile, "");
		index = nextIndex++;
	}
	
	public LibCorr3DModel(String inputFile, String relativeGridPath) throws IOException
	{
		super(inputFile, relativeGridPath);
		index = nextIndex++;
	}
	
	public LibCorr3DModel(String inputFile) throws IOException
	{
		super(inputFile, "");
		index = nextIndex++;
	}
	
	/**
	 * Parameterized constructor, specifying the grid and metadata for the
	 * model. The grid is constructed and the data structures are initialized
	 * based on information supplied in metadata. The data structures are not
	 * populated with any information however (all Profiles are null). The
	 * application should populate the new model's Profiles after this
	 * constructor completes.
	 * 
	 * <p>
	 * Before calling this constructor, the supplied MetaData object must be
	 * populated with required information by calling the following MetaData
	 * methods:
	 * <ul>
	 * <li>setDescription()
	 * <li>setLayerNames()
	 * <li>setAttributes()
	 * <li>setDataType()
	 * <li>setLayerTessIds() (only required if grid has more than one
	 * multi-level tessellation)
	 * <li>setOptimization() (optional: defaults to SPEED)
	 * </ul>
	 * 
	 * @param gridFileName
	 *            String name of file from which to load the grid.
	 * @param metaData
	 *            MetaData the new GeoTessModel instantiates a reference to the 
	 *            supplied metaData.  No copy is made.
	 * @throws IOException
	 */
	public LibCorr3DModel(String gridFileName, GeoTessMetaData metaData)
			throws IOException
	{
		super(gridFileName, metaData);
		this.index = nextIndex++;
		initializeVars();
	}

	/**
	 * Parameterized constructor, specifying the grid and metadata for the
	 * model. The grid is constructed and the data structures are initialized
	 * based on information supplied in metadata. The data structures are not
	 * populated with any information however (all Profiles are null). The
	 * application should populate the new model's Profiles after this
	 * constructor completes.
	 * 
	 * <p>
	 * Before calling this constructor, the supplied MetaData object must be
	 * populated with required information by calling the following MetaData
	 * methods:
	 * <ul>
	 * <li>setDescription()
	 * <li>setLayerNames()
	 * <li>setAttributes()
	 * <li>setDataType()
	 * <li>setLayerTessIds() (only required if grid has more than one
	 * multi-level tessellation)
	 * <li>setOptimization() (optional: defaults to SPEED)
	 * </ul>
	 * 
	 * @param grid
	 *            a reference to the GeoTessGrid that will support this
	 *            GeoTessModel.
	 * @param metaData
	 *            MetaData the new GeoTessModel instantiates a reference to the 
	 *            supplied metaData.  No copy is made.
	 * @throws GeoTessException
	 *             if metadata is incomplete.
	 * @throws IOException
	 */
	public LibCorr3DModel(GeoTessGrid grid, GeoTessMetaData metaData)
			throws GeoTessException, IOException
	{
		super(grid, metaData);
		this.index = nextIndex++;
		initializeVars();
	}

	public LibCorr3DModel(GeoTessModel geotessModel) throws GeoTessException, IOException {
		this(geotessModel.getGrid(), geotessModel.getMetaData());
		for (int v=0; v<geotessModel.getProfiles().length; ++v)
		{
			Profile[] pa = geotessModel.getProfiles(v);
			for (int layer=0; layer<pa.length; ++layer)
				setProfile(v, layer, pa[layer]);
		}
	}

	/**
	 * Overridden IO method.
	 */
	@Override
	protected void loadModelBinary(DataInputStream input,
			String inputDirectory, String relGridFilePath)
			throws GeoTessException, IOException
	{
		try
		{
			// call super class to load model data from binary file.
			super.loadModelBinary(input, inputDirectory, relGridFilePath);
		}
		catch (Exception e1)
		{
			System.err.println(e1.toString());
			System.err.println("Attempting to read as a LibCorr2DModel");

			// the input data file is not in GeoTess format.  Maybe
			// it is a LibCorr2D file (kbcit format).  Try reading that format.
			try
			{
				loadLibCorr2DModel(getMetaData().getInputModelFile(), relGridFilePath);
				// success!
				return;
			}
			catch (Exception e)
			{
				StringBuffer err = new StringBuffer();
				err.append(String.format("%nInput model file is neither a LibCorr3DModel file (GeoTessModel), nor a LibCorr2DModel file (kbcit-generated).%n%s%n%n", 
						getMetaData().getInputModelFile().getCanonicalPath()));
				err.append(GeoTessUtils.getStackTrace(e)).append("\n");
				err.append(GeoTessUtils.getStackTrace(e1)).append("\n");
				throw new IOException(err.toString());
			}
		}

		initializeVars();
		
		String firstWord="";

		// load the extra data managed by this derived class, which
		// is stored at the end of the file.
		try
		{
			firstWord = GeoTessUtils.readString(input);
		}
		catch (java.io.EOFException ex)
		{
			// There is no derived class data in the file after the base class data.
			//
			// this is a regular geotess file, not a libcorr3d file.  
			// We might be able to extract required information from the metadata.
			// This capability was added by sballar 1/23/2017
			formatVersion = -1;
			
			String sta = null;
			long ondate = Site.ONDATE_NA;
			long offdate = Site.OFFDATE_NA;
			double lat = Double.NaN;
			double lon = Double.NaN;
			double elev = Double.NaN;
			String staname = Site.STANAME_NA;
			String statype = Site.STATYPE_NA;
			String refsta = Site.REFSTA_NA;
			double dnorth = Site.DNORTH_NA;
			double deast = Site.DEAST_NA;
			
			String phaseName = null;
			
			String[] fileNameComponents = getMetaData().getInputModelFile().getName().split("_");
			if (fileNameComponents.length >= 3)
			{
				fileNamePhase = fileNameComponents[1];
				fileNameAttribute = fileNameComponents[2];
			}

			for (String record : getMetaData().getDescription().split("\n"))
			{
				if (phaseName == null && record.contains("Pmantle"))
					phaseName = "Pmantle";
				
				if (record.startsWith("phase:") || record.startsWith("phases:"))
					phaseName = record.split(":")[1].trim();
				else if (record.startsWith("sta:"))
					sta = record.split(":")[1].trim();
				else if (record.startsWith("lat:"))
					lat = Double.parseDouble(record.split(":")[1].trim());
				else if (record.startsWith("lon:"))
					lon = Double.parseDouble(record.split(":")[1].trim());
				else if (record.startsWith("depth:"))
					elev = -Double.parseDouble(record.split(":")[1].trim());
				else if (record.startsWith("elev:"))
					elev = Double.parseDouble(record.split(":")[1].trim());
				else if (record.startsWith("dnorth:"))
					dnorth = Double.parseDouble(record.split(":")[1].trim());
				else if (record.startsWith("deast:"))
					deast = Double.parseDouble(record.split(":")[1].trim());
				else if (record.toLowerCase().startsWith("ondate:"))
					ondate = Long.parseLong(record.split(":")[1].trim());
				else if (record.toLowerCase().startsWith("offdate:"))
					offdate = Long.parseLong(record.split(":")[1].trim());
				else if (record.toLowerCase().startsWith("staname:"))
					staname = record.split(":")[1].trim();
				else if (record.toLowerCase().startsWith("statype:"))
					statype = record.split(":")[1].trim();
				else if (record.toLowerCase().startsWith("refsta:"))
					refsta = record.split(":")[1].trim();
				
			}	
			
			setPhase(phaseName);
			
			if (sta != null 
					&& !Double.isNaN(lat)
					&& !Double.isNaN(lon)
					&& !Double.isNaN(elev))
				site = new Site(sta, ondate, offdate, lat, lon, elev, staname,
						statype, refsta, dnorth, deast);
			
			getMetaData().getProperties().put("site", site.toStringTabs());
			getMetaData().getProperties().put("phase", phase);
			getMetaData().getProperties().put("supportedPhases", getSupportedPhasesString());

			return;
		}

		// OK, this is a LibCorr3DModel
		formatVersion = 0;
		// if firstWord starts with 'LibCorr3DModel', then also read the version number
		if (firstWord.startsWith(this.getClass().getSimpleName()))
			formatVersion = input.readInt();
		
		if (formatVersion >= 2)
		{
			// Note: ondate and offdate are read/written as epoch times because c++ version
			// requires it.
			site = new Site(Globals.readString(input), 
					GMTFormat.getJDate(input.readDouble()), 
					GMTFormat.getJDate(input.readDouble()), 
					input.readDouble(), input.readDouble(), input.readDouble(),
					Globals.readString(input), Globals.readString(input), 
					Globals.readString(input), input.readDouble(), input.readDouble());
			
			String ph = GeoTessUtils.readString(input);
			String phList = GeoTessUtils.readString(input);
			setSupportedPhasesString(ph, phList);
			
			setParameters(GeoTessUtils.readString(input));
			setComments(GeoTessUtils.readString(input));
			setBaseModel(GeoTessUtils.readString(input));
			setBaseModelVersion(GeoTessUtils.readString(input));
		}
		else if (formatVersion == 1)
		{
			String sta = GeoTessUtils.readString(input);
			String refsta = GeoTessUtils.readString(input);
			double lat = input.readDouble();
			double lon = input.readDouble();
			double elev = -input.readDouble();
			long onDate = GMTFormat.getJDate(input.readDouble());
			long offDate = GMTFormat.getJDate(input.readDouble());

			site = new Site(sta, onDate, offDate, lat, lon, elev, Site.STANAME_NA,
					Site.STATYPE_NA, refsta, Site.DNORTH_NA, Site.DEAST_NA);

			// read the phase
			setPhase(GeoTessUtils.readString(input));

			setParameters(GeoTessUtils.readString(input));
			setComments(GeoTessUtils.readString(input));
			setBaseModel(GeoTessUtils.readString(input));
			setBaseModelVersion(GeoTessUtils.readString(input));

			String[] fileNameComponents = getMetaData().getInputModelFile().getName().split("_");
			if (fileNameComponents.length >= 3)
			{
				fileNamePhase = fileNameComponents[1];
				fileNameAttribute = fileNameComponents[2];
			}
		}		
		else if (formatVersion == 0)
		{
			// the very first version of LibCorr3DModel started immediately 
			// with the station name.  It did not start with 'LibCorr3DModel' and 
			// the format version number.  
			String sta = firstWord;
			double lat = input.readDouble();
			double lon = input.readDouble();
			double elev = -input.readDouble();
			long onDate = GMTFormat.getJDate(input.readDouble());
			long offDate = GMTFormat.getJDate(input.readDouble());

			site = new Site(sta, onDate, offDate, lat, lon, elev, Site.STANAME_NA,
					Site.STATYPE_NA, Site.REFSTA_NA, Site.DNORTH_NA, Site.DEAST_NA);

			setPhase(GeoTessUtils.readString(input));
			setParameters(GeoTessUtils.readString(input));
			setComments(GeoTessUtils.readString(input));
			setBaseModel(GeoTessUtils.readString(input));
			setBaseModelVersion(GeoTessUtils.readString(input));

			if (parameters.length() == 0)
			{
				for (int i=0; i<getMetaData().getNAttributes(); ++i)
					parameters = parameters + String.format(", %s (%s)", 
							getMetaData().getAttributeNames()[i],
							getMetaData().getAttributeUnit(i));
				parameters = parameters.substring(2);
			}

			String[] fileNameComponents = getMetaData().getInputModelFile().getName().split("_");
			if (fileNameComponents.length >= 3)
			{
				fileNamePhase = fileNameComponents[1];
				fileNameAttribute = fileNameComponents[2];
			}

			if (baseModel.length() == 0 && getMetaData().getAttributeNamesString().contains("AK135"))
				baseModel = "AK135";

		}
		
		getMetaData().getProperties().put("site", site.toStringTabs());
		getMetaData().getProperties().put("phase", phase);
		getMetaData().getProperties().put("supportedPhases", getSupportedPhasesString());
	}

	/**
	 * Overridden IO method.
	 */
	@Override
	protected void writeModelBinary(DataOutputStream output, String gridFileName)
			throws IOException
	{
	    // make sure that metaData has references to current site, phase and supportedPhases
		getMetaData().getProperties().put("site", site.toStringTabs());
		getMetaData().getProperties().put("phase", phase);
		getMetaData().getProperties().put("supportedPhases", getSupportedPhasesString());

		// call super class to write standard model information to binary file.
		super.writeModelBinary(output, gridFileName);

		if (formatVersion == 0)
			formatVersion = defaultFormatVersion;

		// write 'LibCorr3DModel' and version number
		GeoTessUtils.writeString(output, this.getClass().getSimpleName());
		output.writeInt(formatVersion);

		if (formatVersion == 1)
		{
			GeoTessUtils.writeString(output, site.getSta());
			GeoTessUtils.writeString(output, site.getRefsta());
			
			output.writeDouble(site.getLat());
			output.writeDouble(site.getLon());
			output.writeDouble(-site.getElev());
			output.writeDouble(GMTFormat.getEpochTime(site.getOndate()));
			output.writeDouble(GMTFormat.getOffTime(site.getOffdate()));
			
			GeoTessUtils.writeString(output, phase);
			GeoTessUtils.writeString(output, parameters);
			GeoTessUtils.writeString(output, comments);
			GeoTessUtils.writeString(output, baseModel);
			GeoTessUtils.writeString(output, baseModelVersion);
		}
		else
		{
			// write version 2

			// Note: ondate and offdate are read/written as epoch times because c++ version
			// requires it.
			Globals.writeString(output, site.getSta());
			output.writeDouble(site.getOntime());
			output.writeDouble(site.getOfftime());
			output.writeDouble(site.getLat());
			output.writeDouble(site.getLon());
			output.writeDouble(site.getElev());
			Globals.writeString(output, site.getStaname());
			Globals.writeString(output, site.getStatype());
			Globals.writeString(output, site.getRefsta());
			output.writeDouble(site.getDnorth());
			output.writeDouble(site.getDeast());


			GeoTessUtils.writeString(output, getPhase());
			GeoTessUtils.writeString(output, getSupportedPhasesString());

			GeoTessUtils.writeString(output, getParameters());
			GeoTessUtils.writeString(output, getComments());
			GeoTessUtils.writeString(output, getBaseModel());
			GeoTessUtils.writeString(output, getBaseModelVersion());
		}
	}

	/**
	 * Overridden IO method.
	 */
	@Override
	protected void loadModelAscii(Scanner input, String inputDirectory,
			String relGridFilePath) throws GeoTessException, IOException
	{
		super.loadModelAscii(input, inputDirectory, relGridFilePath);

		initializeVars();

		if (!input.hasNext())
			throw new IOException("\nThis model does not appear to be a LibCorr3DModel because\n" +
					"it does not contain the 'extra' LibCorr3D information");

		String line = input.nextLine();

		formatVersion = 0;
		// if line is 'LibCorr3DModel', then also read the version number
		if (line.equals(this.getClass().getSimpleName()))
			formatVersion = Integer.parseInt(input.nextLine()); 

		if (formatVersion >= 2)
		{
			// Note: ondate and offdate are read/written as epoch times because c++ version
			// requires it.
			site = new Site();
			
			line = input.nextLine();
			site.setSta(line.substring(line.indexOf(":")+1).trim());

			line = input.nextLine();
			site.setOntime(Double.parseDouble(line.substring(line.indexOf(":")+1).trim()));

			line = input.nextLine();
			site.setOfftime(Double.parseDouble(line.substring(line.indexOf(":")+1).trim()));

			line = input.nextLine();
			site.setLat(Double.parseDouble(line.substring(line.indexOf(":")+1).trim()));

			line = input.nextLine();
			site.setLon(Double.parseDouble(line.substring(line.indexOf(":")+1).trim()));

			line = input.nextLine();
			site.setElev(Double.parseDouble(line.substring(line.indexOf(":")+1).trim()));

			line = input.nextLine();
			site.setStaname(line.substring(line.indexOf(":")+1).trim());

			line = input.nextLine();
			site.setStatype(line.substring(line.indexOf(":")+1).trim());

			line = input.nextLine();
			site.setRefsta(line.substring(line.indexOf(":")+1).trim());

			line = input.nextLine();
			site.setDnorth(Double.parseDouble(line.substring(line.indexOf(":")+1).trim()));

			line = input.nextLine();
			site.setDeast(Double.parseDouble(line.substring(line.indexOf(":")+1).trim()));

			line = input.nextLine(); // skip comment
			String ph = line.substring(line.indexOf(":")+1).trim();

			line = input.nextLine(); // skip comment
			String phList = line.substring(line.indexOf(":")+1).trim();

			setSupportedPhasesString(ph, phList);

			line = input.nextLine(); // skip comment
			setParameters(line.substring(line.indexOf(":")+1).trim());

			line = input.nextLine(); // skip comment
			setComments(line.substring(line.indexOf(":")+1).trim());

			line = input.nextLine(); // skip comment
			setBaseModel(line.substring(line.indexOf(":")+1).trim());

			line = input.nextLine(); // skip comment
			setBaseModelVersion(line.substring(line.indexOf(":")+1).trim());

		}
		else if (formatVersion == 1)
		{
			input.nextLine(); // skip second comment line

			String staName = input.next();
			String refsta = input.next();
			// station latitude in degrees
			double lat = input.nextDouble();
			// station longitude in degrees
			double lon = input.nextDouble();
			// station depth in km (negative elevation)
			double depth = input.nextDouble();
			// epoch time when station became active
			double onTime = input.nextDouble();
			// epoch time when station became inactive.
			double offTime = input.nextDouble();

			site = new Site(staName, GMTFormat.getJDate(onTime), GMTFormat.getJDate(offTime),
					lat, lon, -depth, Site.STANAME_NA, Site.STATYPE_NA, refsta,
					Site.DNORTH_NA, Site.DEAST_NA);

			input.nextLine(); // skip end of line

			input.nextLine(); // skip comment line
			setPhase(input.nextLine().trim());

			input.nextLine(); // skip comment line
			setParameters(input.nextLine().trim());

			input.nextLine(); // skip comment line
			setComments(input.nextLine().trim());

			input.nextLine(); // skip comment line
			setBaseModel(input.nextLine().trim());

			input.nextLine(); // skip comment line
			setBaseModelVersion(input.nextLine().trim());

			String[] fileNameComponents = getMetaData().getInputModelFile().getName().split("_");
			if (fileNameComponents.length >= 3)
			{
				fileNamePhase = fileNameComponents[1];
				fileNameAttribute = fileNameComponents[2];
			}
		}			
		else if (formatVersion == 0)
		{
			try
			{
				input.nextLine(); // skip second comment line

				String staName = input.next();
				double lat = input.nextDouble();
				double lon = input.nextDouble();
				double depth = input.nextDouble();
				double onTime = input.nextDouble();
				double offTime = input.nextDouble();

				site = new Site(staName, GMTFormat.getJDate(onTime), GMTFormat.getJDate(offTime),
						lat, lon, -depth, Site.STANAME_NA, Site.STATYPE_NA, Site.REFSTA_NA,
						Site.DNORTH_NA, Site.DEAST_NA);

				input.nextLine(); // skip end of line

				input.nextLine(); // skip comment line
				setPhase(input.nextLine().trim());

				input.nextLine(); // skip comment line
				setParameters(input.nextLine().trim());

				input.nextLine(); // skip comment line
				setComments(input.nextLine().trim());

				input.nextLine(); // skip comment line
				setBaseModel(input.nextLine().trim());

				input.nextLine(); // skip comment line
				setBaseModelVersion(input.nextLine().trim());

				String[] fileNameComponents = getMetaData().getInputModelFile().getName().split("_");
				if (fileNameComponents.length >= 3)
				{
					fileNamePhase = fileNameComponents[1];
					fileNameAttribute = fileNameComponents[2];
				}
			}
			catch (Exception e)
			{
				e.printStackTrace();
			}
		}
		
		getMetaData().getProperties().put("site", site.toStringTabs());
		getMetaData().getProperties().put("phase", phase);
		getMetaData().getProperties().put("supportedPhases", getSupportedPhasesString());
	}

	/**
	 * Overridden IO method.
	 */
	@Override
	protected void writeModelAscii(Writer output, String gridFileName)
			throws IOException
	{
	    // make sure that metaData has references to current site, phase and supportedPhases
		getMetaData().getProperties().put("site", site.toStringTabs());
		getMetaData().getProperties().put("phase", phase);
		getMetaData().getProperties().put("supportedPhases", getSupportedPhasesString());

		// call super class to write standard model information to binary file.
		super.writeModelAscii(output, gridFileName);

		// write the extra data managed by this derived class, which
		// is stored at the end of the file.
		
		if (formatVersion == 0)
			formatVersion = defaultFormatVersion;

		// output 'LibCorr3DModel', followed by version number.
		output.write(String.format("%s%n%d%n", this.getClass().getSimpleName(), formatVersion));

		// Note: ondate and offdate are read/written as epoch times because c++ version
		// requires it.

		if (formatVersion == 1)
		{
			output.write("# sta, refsta, lat, lon, depth, onTime, offTime:\n");

			output.write(String.format(
					"%s %s %1.6f %1.6f %1.4f %1.3f %1.3f%n", 
					site.getSta(), 
					site.getRefsta(), 
					site.getLat(), 
					site.getLon(),
					-site.getElev(),
					site.getOntime(),
					site.getOfftime()));

			output.write(String.format("# phase%n%s%n", phase));
			output.write(String.format("# parameters%n%s%n", parameters));
			output.write(String.format("# comments%n%s%n", comments));
			output.write(String.format("# baseModel%n%s%n", baseModel));
			output.write(String.format("# baseModelVersion%n%s%n", baseModelVersion));
		}
		else
		{
			// write version 2

			output.write(String.format("sta:     %s%n"
					+ "ontime:  %1.3f%n"
					+ "offtime: %1.3f%n"
					+ "lat:     %1.6f%n"
					+ "lon:     %1.6f%n"
					+ "elev:    %1.4f%n"
					+ "staname: %s%n"
					+ "statype: %s%n"
					+ "refsta:  %s%n"
					+ "dnorth:  %1.3f%n"
					+ "deast:   %1.3f%n",
					site.getSta(), 
					site.getOntime(), site.getOfftime(), 
					site.getLat(), site.getLon(), site.getElev(), 
					site.getStaname(), site.getStatype(), site.getRefsta(), 
					site.getDnorth(), site.getDeast()));

			output.write(String.format("phase: %s%n", getPhase()));

			output.write(String.format("supported phases: %s%n", getSupportedPhasesString()));

			output.write(String.format("parameters: %s%n", getParameters()));

			output.write(String.format("comments: %s%n", getComments()));

			output.write(String.format("base model: %s%n", getBaseModel()));

			output.write(String.format("base model version: %s%n", getBaseModelVersion()));		

		
		}
}

  /**
	 * Overridden equal method.
	 */
	@Override
	public boolean equals(Object other)
	{
		if (this == other) return true;
		if (other == null) return false;
		if (!(other instanceof LibCorr3DModel)) return false;
		
		return this.site.equals(((LibCorr3DModel) other).site)
				&& this.phase.equals(((LibCorr3DModel) other).phase)
				&& this.supportedPhases.equals(((LibCorr3DModel) other).supportedPhases)
				&& this.parameters.equals(((LibCorr3DModel) other).parameters)
				&& this.comments.equals(((LibCorr3DModel) other).comments)
				&& this.baseModel.equals(((LibCorr3DModel) other).baseModel)
				&& this.baseModelVersion.equals(((LibCorr3DModel) other).baseModelVersion)
				&& super.equals(other);
	}

	@Override
	public String toString()
	{
	  StringBuffer buf = new StringBuffer(super.toString());
	  buf.append(String.format("%nLibCorr3DModel data:%n"
		  + "sta:     %s%n"
	      + "ondate:  %d%n"
	      + "offdate: %d%n"
	      + "lat:     %1.6f%n"
	      + "lon:     %1.6f%n"
	      + "elev:    %1.4f%n"
	      + "staname: %s%n"
	      + "statype: %s%n"
	      + "refsta:  %s%n"
	      + "dnorth:  %1.3f%n"
	      + "deast:   %1.3f%n"
	      + "phase:      %s%n"
	      + "suportedPhases: %s%n"
	      + "velocityModel: %s%n"
	      + "baseModel:  %s%n"
	      + "baseModelVersion: %s%n"
	      + "parameters: %s%n"
	      + "comments:   %s%n"
	      + "formatVersion: %d%n",
	      site.getSta(), 
	      site.getOndate(), 
	      site.getOffdate(), 
	      site.getLat(), 
	      site.getLon(), 
	      site.getElev(), 
	      site.getStaname(), 
	      site.getStatype(), 
	      site.getRefsta(), 
	      site.getDnorth(), 
	      site.getDeast(),
	      phase,
	      supportedPhases.toString().replace("[", "").replace("]", ""),
	      getVmodel(),
	      baseModel, baseModelVersion, parameters, comments, formatVersion));


	  return buf.toString();
	}

	protected void initializeVars()
	{
		site = new Site();

		phase = "";
		supportedPhases = new ArrayList<String>();
		parameters = "";
		comments = "";
		baseModel = "";
		baseModelVersion = "";
	}
	
	/**
	 * Set the parameters attribute equal to the attributes
	 * and units extracted from the model metadata object, 
	 * e.g.: "TT_DELTA_AK135 (seconds), TT_MODEL_UNCERTAINTY (seconds)"
	 */
    public void setParametersToMetaDataValues()
    {  
      if (getMetaData() != null)
      {
        for (int i=0; i<getMetaData().getNAttributes(); ++i)
          parameters = parameters + String.format(", %s (%s)", 
              getMetaData().getAttributeNames()[i],
              getMetaData().getAttributeUnit(i));
        parameters = parameters.substring(2);
      }
    }

    /**
     * If any attribute retrieved from the model metadata object 
     * contains the substring "AK135", then the basemodel attribute
     * is set to "AK135".
     */
    public void setBaseModelToMetaDataValues()
    {  
      if (getMetaData() != null && getMetaData().getAttributeNamesString().contains("AK135"))
          baseModel = "AK135";
    }

	/**
	 * List of phases this model supports.
	 * @return a copy of the current supportedAttributes ArrayList.
	 */
	public List<String> getSupportedPhases()
	{
	  // return a copy of the current supportedAttributes ArrayList.
	  return new ArrayList<String>(supportedPhases);
	}
	
    public String getSupportedPhasesString() {
      return supportedPhases.toString().replace("[", "").replace("]", "");
    }

	/**
	 * Get the phase string.
	 */
	public String getPhase()
	{
		return phase;
	}

	public String getParameters()
	{
		return parameters;
	}

	public String getComments()
	{
		return comments;
	}

	public String getBaseModel()
	{
		return baseModel;
	}

	public String getBaseModelVersion()
	{
		return baseModelVersion;
	}
	
	public String getVmodel() {
	    String vmodel = getMetaData().getProperties().get("vmodel");
	    if (vmodel == null) {
		vmodel = "libcorr3dmodel";
		String uncert = "";
		Scanner scn = new Scanner(getMetaData().getDescription());
		while (scn.hasNextLine()) {
		    String line = scn.nextLine().toLowerCase();
		    if (line.startsWith("bendermodel") && line.contains("salsa3d")) {
			vmodel = "salsa3d";
			if (line.contains("v2.1"))
			    vmodel = "salsa3d.2.1";
		    }
		    if (line.startsWith("reporting") && line.contains("uncertainty")) {
			if (line.contains("path"))
			    uncert = "_pdu";
			else if (line.contains("distance"))
			    uncert = "_ddu";
		    }
		}
		vmodel = vmodel+uncert;
		
		getMetaData().getProperties().put("vmodel", vmodel);
	    }
	    return vmodel;
	}

	/**
	 * Set the seismic phase.
	 * If 'Pmantle' is specified then supportedPhases will equal P and Pn.
	 * Otherwise the listOfPhases will be parsed, supportedPhases
	 * will be set to parsed list and phase will be set to the first phase in the list.
	 * @param listOfPhases a comma and/or space delimited list of phase names.
	 * @return reference to this.
	 */
	public LibCorr3DModel setPhase(String listOfPhases)
	{
	  if (listOfPhases.equals("Pmantle"))
	  {
	    supportedPhases = Arrays.asList("P", "Pn");
	    phase = "Pmantle";
	  }
	  else
	  {
	    supportedPhases = Arrays.asList(listOfPhases.trim().replaceAll(",", " ").split("\\s+"));
	    phase = supportedPhases.get(0);
	  }

	  return this;
	}

	/**
	 * Set of phases supported by this model.
	 * If supportedPhases = [P, Pn] then phase is set to "Pmantle"
	 * otherwise phase is set to the first phase in the list.
	 * @param supportedPhases
	 */
	public LibCorr3DModel setSupportedPhases(List<String> supportedPhases)
	{
	  this.supportedPhases = supportedPhases;

	  if (supportedPhases.size() == 2 && supportedPhases.contains("P")
	      && supportedPhases.contains("Pn"))
	    this.phase = "Pmantle";
	  else if (supportedPhases.isEmpty())
	    this.phase = "";
	  else
	    this.phase = supportedPhases.get(0).trim();
	  return this;
	}

    /**
     * Set both the phase and the list of supported phases, with no shenanigans
     * @param phase 
     * @param supportedPhases
     */
    public void setSupportedPhases(String phase, List<String> supportedPhases) {
      this.phase = phase;
      this.supportedPhases = supportedPhases;
    }

    /**
     * Set both the phase and the list of supported phases, with no shenanigans
     * @param phase 
     * @param supportedPhasesString comma and/or space delimited list of phases
     */
    public void setSupportedPhasesString(String phase, String supportedPhasesString) {
      setSupportedPhases(phase, Arrays.asList(
          supportedPhasesString.trim().replaceAll(",", " ").split("\\s+")));
      this.phase = phase;
    }

	/**
	 * 
	 * @param parameters
	 * @return reference to this.
	 */
	public LibCorr3DModel setParameters(String parameters)
	{
		this.parameters = parameters;
		return this;
	}

	/**
	 * 
	 * @param comments
	 * @return reference to this.
	 */
	public LibCorr3DModel setComments(String comments)
	{
		this.comments = comments;
		return this;
	}

	/**
	 * 
	 * @param baseModel
	 * @return reference to this.
	 */
	public LibCorr3DModel setBaseModel(String baseModel)
	{
		this.baseModel = baseModel;
		return this;
	}

	/**
	 * 
	 * @param baseModelVersion
	 * @return reference to this.
	 */
	public LibCorr3DModel setBaseModelVersion(String baseModelVersion)
	{
		this.baseModelVersion = baseModelVersion;
		return this;
	}
	
	public int getFormatVersion() {
		return formatVersion;
	}

	public void setFormatVersion(int formatVersion) {
		this.formatVersion = formatVersion;
	}

	/**
	 * Copy the 'extra' data from other to this.
	 * @param other
	 */
	public void copyLibCorrData(LibCorr3DModel other)
	{
		this.site = new Site(other.site);
		this.phase = other.phase;
		this.supportedPhases = new ArrayList<String>(other.supportedPhases);
		this.parameters = other.parameters;
		this.comments = other.comments;
		this.baseModel = other.baseModel;
		this.baseModelVersion = other.baseModelVersion;		
	}

	/**
	 * Retrieve a reference to the Site that this model supports.
	 * @return a reference to the Site that this model supports.
	 */
	public Site getSite()
	{
		return site;
	}

	/**
	 * Replace the current Site object with a new one.
	 * @param station
	 * @return a reference to this.
	 */
	public LibCorr3DModel setSite(Site station)
	{
		this.site = station;
		return this;
	}

	/**
	 * Replace the current Site object with a new one.
	 * @param sta
	 * @param ondate
	 * @param offdate
	 * @param lat
	 * @param lon
	 * @param elev
	 * @param staname
	 * @param statype
	 * @param refsta
	 * @param dnorth
	 * @param deast
	 */
	public void setSite(String sta, long ondate, long offdate, double lat, double lon, double elev,
			String staname, String statype, String refsta, double dnorth, double deast) {
		this.site = new Site(sta, ondate, offdate, lat, lon, elev, staname, statype, refsta, dnorth, deast);
	}
	
	/**
	 * Replace the current Site object with a new one.
	 * @param sta
	 * @param ondate
	 * @param offdate
	 * @param lat
	 * @param lon
	 * @param elev
	 * @param staname
	 * @param statype
	 * @param refsta
	 * @param dnorth
	 * @param deast
	 */
	public void setSite(String sta, int ondate, int offdate, double lat, double lon, double elev,
			String staname, String statype, String refsta, double dnorth, double deast) {
		this.site = new Site(sta, (long)ondate, (long)offdate, lat, lon, elev, staname, statype, refsta, dnorth, deast);
	}
	
	/**
	 * The fileName is supposed to be of the form:
	 *  &lt;sta&gt;_&lt;phase&gt;_&lt;TT | AZ | SLO&gt;_&lt;ondate&gt;_&lt;offdate&gt;.
	 *  If true, then this method returns the name of the 
	 *  phase extracted from the fileName, otherwise, 
	 *  "".
	 * @return phase name extracted from the file name.
	 */
	public String getFileNamePhase()
	{
		return fileNamePhase;
	}

	/**
	 * The fileName is supposed to be of the form:
	 *  &lt;sta&gt;_&lt;phase&gt;_&lt;TT | AZ | SLO&gt;_&lt;ondate&gt;_&lt;offdate&gt;.
	 *  If true, then this method returns the name of the 
	 *  attribute extracted from the fileName 
	 *  (one of TT | AZ | SLO), otherwise, 
	 *  "".
	 * @return attribute name extracted from the file name
	 * (one of TT | AZ | SLO).
	 */
	public String getFileNameAttribute()
	{
		return fileNameAttribute;
	}


	/**
	 * Try to load the model in LibCorr2D (kbcit) format.
	 * @param inputFile
	 * @param relGridFilePath
	 * @param relGridFilePath
	 * @throws Exception 
	 */
	private void loadLibCorr2DModel(File inputFile, String relGridFilePath)
			throws Exception
	{
		initializeVars();
		
		CustomStream input = new CustomStream(inputFile);

		StringBuffer description = new StringBuffer(input.readString().replaceAll(".  ", ".  \n")+"\n");
		
		String parameters = input.readString();
		description.append("parameters: "+parameters+"\n");
		
		String comments = input.readString();
		description.append("comments: "+comments+"\n");
		
		// tt, az, slo, amp
		String attributeType = input.readString();
		description.append("attributeType: "+attributeType+"\n");
		
		String softwareVersionString = input.readString();
		description.append("softwareVersionString: "+softwareVersionString+"\n");
		
		String baseModel = input.readString();
		description.append("baseModel: "+baseModel+"\n");
		
		String baseModelVersion = input.readString();
		description.append("baseModelVersion: "+baseModelVersion+"\n");
		
		String sta = input.readString();
		description.append("sta: "+sta+"\n");
		
		String phase = input.readString();
		description.append("phase: "+phase+"\n");
		
		double startTime = input.readDouble();
		description.append("startTime: "+startTime+"\n");
		
		double endTime = input.readDouble();
		description.append("endTime: "+endTime+"\n");
		
		String gridID = input.readString();
		description.append("gridID: "+gridID+"\n");
		
		// read the path correction and uncertainty info
		float[][] data = new float[input.readInt()][2];
		input.readArray(data);
		
		String comment = input.readString();
		description.append("comment: "+comment+"\n");
		
		input.close();
		
		// work on populating the GeoTessMetaData object.
		
		getMetaData().setLayerNames("surface");
		
		if (attributeType.equalsIgnoreCase("tt"))
		{
			getMetaData().setAttributes("TT_DELTA_AK135; TT_MODEL_UNCERTAINTY", "seconds; seconds");
			parameters = "TT_DELTA_AK135 (seconds), TT_MODEL_UNCERTAINTY (seconds)";
		}
		else if (attributeType.equals("slo"))
		{
			getMetaData().setAttributes("SLOWNESS_PATH_CORRECTION; SLOWNESS_MODEL_UNCERTAINTY", "seconds/radian; seconds/radian");
			parameters = "SLOWNESS_PATH_CORRECTION (seconds/radian), SLOWNESS_MODEL_UNCERTAINTY (seconds/radian)";
			// sballar; 8/2/2017; i verified that libcorr2d slowness surfaces are in units of
			// seconds/radian. No unit conversion necessary.
		}
		else if (attributeType.equals("az"))
		{
			getMetaData().setAttributes("AZIMUTH_PATH_CORRECTION; AZIMUTH_MODEL_UNCERTAINTY", "radians; radians");
			parameters = "AZIMUTH_PATH_CORRECTION (radians), AZIMUTH_MODEL_UNCERTAINTY (radians)";
			// sballar; 8/2/2017; i verified that libcorr2d azimuth surfaces are in units of
			// radians.  No unit conversion necessary.
		}
		else 
			throw new IOException(String.format("attributeType='%s' but must be one of [ tt | slo | az ]%n", attributeType));
		
		getMetaData().setDataType(DataType.FLOAT);
		getMetaData().setModelSoftwareVersion(comment + " translated by " +getClass().getCanonicalName());
		String generationDate = "";
		try
		{
			// the description field in the test files contained a substring like:
			// "at epoch time (213456789)."  We will try to parse that to get the 
			// epoch time when the kbcit file was generated.  If this fails for any
			// reason, we will ignore the error and go on.
			int idx = description.indexOf("at epoch time");
			if (idx >= 0)
			{
				String s = description.substring(idx);
				int i1 = s.indexOf("(");
				int i2 = s.indexOf(")");
				if (i1>=0 && i2 >= 0)
				{
					generationDate = GMTFormat.GMT.format(
							GMTFormat.getDate(Double.parseDouble(s.substring(i1+1,i2))));
					
					generationDate += " GMT translated ";
				}
			}
		}
		catch (Exception e)
		{
			generationDate = "";
		}
		generationDate += GMTFormat.getNow();
		
		getMetaData().setModelGenerationDate(generationDate);

		// work on setting up the grid.
		
		GeoTessGrid grid = null;
		if (getMetaData().isGridReuseOn())
			grid = getGridMap().get(gridID);
		
		if (grid == null)
		{
			File tessDir = new File(inputFile.getParentFile(), relGridFilePath);
			File gridFile = new File(tessDir, gridID);

			grid = loadGrid(gridFile);
			grid.setInputGridSoftwareVersion(comment + " translated by " +getClass().getCanonicalName());
			grid.setInputGridGenerationDate(generationDate);
			getGridMap().put(gridID, grid);
			getMetaData().getProperties().put("gridID", grid.getGridID());
		}
		
		super.setGrid(grid);

		// process the error file.  This is the 1D, distance-dependent travel time uncertainty.
		// The tt uncertainty info loaded from the data file is a modification to the background
		// uncertainty.  
		File errFile = new File(getMetaData().getInputModelFile().getCanonicalPath()+".err");

		if (!errFile.exists())
			throw new IOException(String.format("%nBackground error file does not exist:%n%s%n",
					errFile.getCanonicalPath()));
			
		BackgroundError backgroundModelError = new BackgroundError(errFile);
		
		// add the background uncertainty to the uncertainty attached to each vertex.
		for (int i=0; i<data.length; ++i) data[i][1] += backgroundModelError.getError(getVertex(i));
		
		// populate the Profile objects associated with each vertex
		initializeProfiles();

		for (int vertex=0; vertex < getNVertices(); ++vertex)
			setProfile(vertex, Data.getDataFloat(data[vertex]));

		// make a station object with the sta, onTime and offTime loaded from the data file, and the
		// staLat, staLon, staElev loaded from the background error file.
		Site station = new Site(sta, 
				GMTFormat.getJDate(startTime), 
				GMTFormat.getJDate(endTime), 
				backgroundModelError.staLat, 
				backgroundModelError.staLon, 
				backgroundModelError.staElev,
				Site.STANAME_NA,
				Site.STATYPE_NA,
				sta,
				Site.DNORTH_NA,
				Site.DEAST_NA);

		// set the 'extra' libcorr3d information.  phase comes from the data file
		setSite(station);
		setPhase(phase);
		setBaseModel(baseModel);
		setBaseModelVersion(baseModelVersion);
		setComments(comments);
		setParameters(parameters);
		
		description.append("\n");
		description.append(String.format("sta: %s%n", station.getSta()));
		description.append(String.format("lat: %1.6f%n", station.getLat()));
		description.append(String.format("lon: %1.6f%n", station.getLon()));
		description.append(String.format("elev: %1.4f%n", station.getElev()));
		description.append(String.format("ondate: %1d%n", station.getOndate()));
		description.append(String.format("offdate: %1d%n", station.getOffdate()));
		
		description.append("\n");
		description.append(String.format("START_PATH_CORRECTION_TYPES:%n")); 
		description.append(String.format("kbcit empirical corrections loaded from %s%n",
				getMetaData().getInputModelFile())); 
		description.append(String.format("END_PATH_CORRECTION_TYPES%n")); 

		description.append("\n");
		description.append("Background model error:\n"+backgroundModelError.toString());
				
		getMetaData().setDescription(description.toString());
		
		getMetaData().getProperties().put("site", site.toStringTabs());
		getMetaData().getProperties().put("phase", phase);
		getMetaData().getProperties().put("supportedPhases", getSupportedPhasesString());

		// code for testing that errors are properly interpolated.

//		System.out.println("LibCorr3DModel.java background error:\n"+error.toString());
//		double[] u = new double[3];
//		for (int i=0; i<100; ++i)
//		{
//			GeoTessUtils.move(station.getVector(), Math.toRadians(i*0.1), 0, u);
//			System.out.printf("%10.6f %10.6f%n", GeoTessUtils.angleDegrees(station.getVector(), u),
//					error.getError(u));
//		}
		
	}
	
	private GeoTessGrid loadGrid(File inputFile) throws IOException
	{
		CustomStream input = new CustomStream(inputFile);
		input.readString(); // tessFileDescription
		input.readString(); // tessFileParamList
		input.readString(); // userComments
		
		// load the longitude and latitude of every vertex, in degrees
		double[][] vertices = new double[input.readInt()][2];	
		input.readArray(vertices);
		
		// convert the lat, lons to unit vectors
		for (int i=0; i<vertices.length; ++i)
			vertices[i] = EarthShape.WGS84.getVectorDegrees(vertices[i][0], vertices[i][1]);
		
		// load the triangle definitions.
		int[][] triangles = new int[input.readInt()][3];
		for (int i=0; i<triangles.length; ++i)
		{
			int[] idx = triangles[i];
			// pgl writes indices in counterclockwise order but
			// geotess wants them in clockwise order.  So switch the order.
			idx[0] = input.readInt();
			idx[2] = input.readInt();
			idx[1] = input.readInt();
		}
		input.close();
		
		// build a GeoTessGrid object with the vertices and triangles.  The grid will have
		// only one multi-level tessellation with a single level.
		try
		{
			int[][] tessellation = new int[][] {{0, 1}};
			int[][] levels = new int[][] {{0, triangles.length}};
			GeoTessGrid grid = new GeoTessGrid(tessellation, levels, 
					triangles, vertices);
			//grid.setGridInputFile(inputFile);
			return grid;
		}
		catch (GeoTessException e)
		{
			throw new IOException(e);
		}		
	}
	
	class BackgroundError
	{
		// this information is extracted from the file name.
		String sta="-";
		String phase="-";
		String attribute="-";
		long onDate=-1;
		long offDate=-1;
		
		// this information is extracted from inside the file.
		double staLat;
		double staLon;
		double staElev;
		
		/**
		 * Unit vector position
		 */
		double[] location;
		
		Site station = null;
		
		/**
		 * Distance from station in degrees
		 */
		float[] distances; 
		
		/**
		 * Azimuth uncertainties are in radians, 
		 * slowness uncertainties are in sec/radian
		 */
		float[] errors;
		
		BackgroundError(File inputFile) throws IOException
		{
			CustomStream input = new CustomStream(inputFile);
			staLon = input.readDouble();
			staLat = input.readDouble();
			location = EarthShape.WGS84.getVectorDegrees(staLat, staLon);
			staElev = -input.readDouble();
			distances = new float[input.readInt()];
			errors = new float[distances.length];
			for (int i=0; i<distances.length; ++i)
			{
				distances[i] = input.readFloat();
				errors[i] = input.readFloat();
			}
			input.close();
			
			try
			{
				String name = inputFile.getName();
				int dot=name.indexOf('.');
				if (dot > 0)
				{
					String[] parts = name.substring(0, dot).split("_");
					if (parts.length == 5)
					{
						sta = parts[0];
						phase = parts[1];
						attribute = parts[2];
						onDate = Long.parseLong(parts[3]);
						offDate = Long.parseLong(parts[4]);
						
//						Site station = new Site(sta, 
//								onDate, offDate, 
//								staLat, staLon, staElev,
//								Site.STANAME_NA,
//								Site.STATYPE_NA,
//								sta,
//								Site.DNORTH_NA,
//								Site.DEAST_NA);
					}
						
				}
			}
			catch (Exception e)
			{
				station = null;
			}
		}
		
		@Override
		public String toString()
		{
			StringBuffer buf = new StringBuffer();
//			if (station == null)
//				buf.append(String.format("Site lat,lon,elev = %1.6f %1.6f %1.3f%n", staLat, staLon, staElev));
//			else 
//				buf.append(String.format("Site = %s%n", station.toString()));
			
			buf.append(String.format("%d%n", distances.length));
			for (int i=0; i<distances.length; ++i)
				buf.append(String.format(" %10.6f %9.6f%n", distances[i], errors[i]));
			return buf.toString();
		}
		
		/**
		 * Get uncertainty at specified geographic location.
		 * travel time uncertainty in seconds,
		 * azimuth uncertainty is in radians,
		 * slowness uncertainty is in sec/radian
		 * @param u
		 * @return
		 */
		float getError(double[] u)
		{
			float distance = (float) GeoTessUtils.angleDegrees(location, u);
			int i = getIndex(distance);
			if (i < 0 || i >= distances.length)
				return Float.NaN;
			if (i == distances.length-1)
				return errors.length-1;
			
			double c = (distances[i+1]-distance)/(distances[i+1]-distances[i]);
			return (float) (errors[i]*c + errors[i+1]*(1-c));
		}

		public int getIndex(float distance)
		{
			int ju,jm,jl;
			//boolean ascnd=(radii[n-1] >= radii[0]);

			jl=-1;
			ju=distances.length;
			while (ju-jl > 1) 
			{
				jm=(ju+jl) >> 1;
				if (distance >= distances[jm]) // == ascnd)
					jl=jm;
				else
					ju=jm;
			}
			return jl;
		}

	}
	
	/**
	 * Wrapper around a DataInputStream that keeps a count of how
	 * many bytes have been read.  Also provides method align() that 
	 * will read zeroes in order to move the file pointer to an 
	 * n-byte boundary.  Methods readInt, readFloat, readDouble and
	 * readArray align the file pointer on the appropriate byte boundary
	 * before reading data from the input stream.
	 * 
	 * @author sballar
	 */
	class CustomStream
	{
		DataInputStream input;
		long count;
		
		CustomStream(File inputFile) throws IOException
		{
			input = new DataInputStream(new BufferedInputStream(
					new FileInputStream(inputFile)));
			count = 0;
		}
		
		CustomStream(DataInputStream inputStream) throws IOException
		{
			input = inputStream;
			count = 0;
		}
		
		public void close() throws IOException { input.close(); }
		
		/**
		 * Read bytes (zeroes) until count is divisible by nbytes.
		 * @param nbytes typically 2, 4 or 8
		 * @throws IOException
		 */
		private void align(long nbytes) throws IOException
		{ count += input.skipBytes((int) ((nbytes - (count % nbytes)) % nbytes)); }
		
		public int readInt() throws IOException
		{
			align(4);
			count += 4;
			return input.readInt();
		}
		
		public float readFloat() throws IOException
		{
			align(4);
			count += 4;
			return input.readFloat();
		}
		
		public double readDouble() throws IOException
		{
			align(8);
			count += 8;
			return input.readDouble();
		}
		
		String readString() throws IOException
		{
			int n = readInt();
			// do not read strings bigger than 10K. Attempting to do so
			// is a good indication that the file format is incorrect.
			if (n < 0 || n > 10240)
				throw new IOException(String.format("%nCannot read a String of size %d%n", n));
			if (n==0) return "";
			byte[] bytes = new byte[n];
			count += input.read(bytes);
			return new String(bytes);
		}
		
		public void readArray(float[][] array) throws IOException
		{
			align(4);
			for (int i=0; i<array.length; ++i)
				for (int j=0; j<array[i].length; ++j)
					array[i][j] = input.readFloat();
		}

		public void readArray(double[][] array) throws IOException
		{
			align(8);
			for (int i=0; i<array.length; ++i)
				for (int j=0; j<array[i].length; ++j)
					array[i][j] = input.readDouble();
		}
	}

	/**
	 * Visit every Point in the model. If the value of the specified attribute is greater
	 * than the specified threshold, then visit all the neighbors at same radius.  Count the 
	 * number of NaNs and compute the average of the non-NaN values. If the number of NaNs
	 * is > 3, set the point value to NaN.  If the absolute value of the difference between
	 * the point value and average of the neighbors values is greater than dnThreshold,
	 * then replace point value with average of the neighbors values.
	 * @param attribute
	 * @param thresholdValue
	 * @param dnThreshold
	 * @return number of points fixed.
	 * @throws Exception
	 */
	public HashMap<Integer, Float> fixAnomalies(int attribute, float thresholdValue) throws Exception {
	    return fixAnomalies(null, attribute, thresholdValue);
	}

	public HashMap<Integer, Float> fixAnomalies(ScreenWriterOutput log, int attribute, float thresholdValue) throws Exception
	{
	    if (thresholdValue == 0.)
		return new HashMap<Integer, Float>();
	    
	    PointMap pm = getPointMap();
	    GeoTessPosition pos = getGeoTessPosition();
	    HashMap<Integer, Float>changes = new HashMap<>();
	    
	    StringBuffer buf = log == null ? null : new StringBuffer();
	    

	    for (int p=0; p<pm.size(); ++p)
	    {
		float value = pm.getPointValueFloat(p, attribute);
		if (!Float.isNaN(value))
		{
		    // find the average of the neighboring values that are not NaN and whose value is < threshold
		    HashSet<Integer> neighbors = getGrid().getVertexNeighbors(0, getGrid().getNLevels(0)-1,
			    pm.getVertexIndex(p));
		    float sum = 0;
		    int n = 0;
		    for (Integer i : neighbors) 
		    {
			float vn = (float) pos.set(getGrid().getVertex(i), pm.getPointRadius(p)).getValue(attribute);
			if (!Float.isNaN(vn) && vn < thresholdValue)
			{
			    sum += vn;
			    ++n;
			}
		    }

		    float average = n > 0 ? sum/n : Float.NaN;
		    float delta = value - average;
		    if (value > thresholdValue || delta > thresholdValue)
		    {
			changes.put(p, average);
			if (buf != null)
			{
			    buf.append(String.format("%d\t%1.3f\t%1.3f",p, value, average));
			    for (Integer i : neighbors) 
				buf.append(String.format("\t%d\t%1.3f", i, pos.set(getGrid().getVertex(i), pm.getPointRadius(p)).getValue(attribute)));
			    buf.append("\n");
			}
		    }
		}
	    }

	    if (log != null) {
		log.writeln(changes.size()+" anomalies detected in LibCorr3DModel.fixAnomalies()");
		if (changes.size() > 0) {
		    log.writeln("pointIndex\toriginal value\tnew value\tneighborIndex\tneighborValue\t...");
		    log.write(buf.toString());
		}
	    }

	    for (Integer p : changes.keySet())
		pm.setPointValue(p, attribute, changes.get(p));

	    return changes;
	}
}
