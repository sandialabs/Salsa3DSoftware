/**
 * Copyright 2009 Sandia Corporation. Under the terms of Contract
 * DE-AC04-94AL85000 with Sandia Corporation, the U.S. Government
 * retains certain rights in this software.
 * 
 * BSD Open Source License.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *    * Redistributions of source code must retain the above copyright notice,
 *      this list of conditions and the following disclaimer.
 *    * Redistributions in binary form must reproduce the above copyright
 *      notice, this list of conditions and the following disclaimer in the
 *      documentation and/or other materials provided with the distribution.
 *    * Neither the name of Sandia National Laboratories nor the names of its
 *      contributors may be used to endorse or promote products derived from
 *      this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
package gov.sandia.gmp.util.numerical.polygon;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.InputStream;
import java.io.PrintStream;
import java.io.Writer;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Scanner;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

import gov.sandia.gmp.util.numerical.vector.VectorGeo;

public class PolygonKMLZ {

	/**
	 * Read a kml or kmz file and parse a List of Polygons.
	 * @param file
	 * @return
	 * @throws Exception
	 */
	public static List<Polygon> readKMLZ(File file) throws Exception
	{
		ZipFile zf = null;
		InputStream is = null;
		Scanner input = null;

		if (file.getName().toLowerCase().endsWith("kml"))
			input = new Scanner(file);
		else
		{
			zf = new ZipFile(file);
			ZipEntry zip = zf.entries().nextElement();
			is = zf.getInputStream(zip);
			input = new Scanner(is);
		}

		// read the entire contents of the kml/kmz file into a buffer.
		StringBuffer buffer = new StringBuffer();
		while (input.hasNext())
			buffer.append(input.next()).append(" ");
		input.close();
		if (is != null) is.close();
		if (zf != null) zf.close();

		List<Polygon> polygons = new ArrayList<>();

		// check if this is a file written by this class
		String writtenby = readElement(buffer, "writtenby").toString();
		boolean sandiaFormat = writtenby.equals("gov.sandia.gmp.util.numerical.polygon.Polygon");

		if (sandiaFormat)
		{
			Set<Integer> processed = new HashSet<>();

			StringBuffer substring = new StringBuffer(readElement(buffer, "Placemark"));
			while (substring.length() > 0)
			{
				int index = Integer.valueOf(readElement(substring, "index"));

				if (!processed.contains(index))
				{
					processed.add(index);

					// these elements have to be read in proper order
					String name = readElement(substring, "name");
					String description = readElement(substring, "description");

					String[] tokens = description.split(";");

					if (tokens[0].equals("Polygon3D"))
					{
						// tokens will look like:
						// 0: Polygon3D
						// 1; TOP HorizonLayer 1 1.000 6
						// 2: BOTTOM HorizonDepth 1 4000.000 -1
						// 3: Polygon2D class
						// 4: String that depends on Polygon2D class
						Horizon top = Horizon.getHorizon(tokens[1]);
						Horizon bottom = Horizon.getHorizon(tokens[2]);
						Polygon2D polygon2d = parsePolygon2D(new String[] {tokens[3], tokens[4]},
								substring).setName(name);
						polygons.add(new Polygon3D(polygon2d, bottom, top).setName(name));
					}
					else 
						polygons.add(parsePolygon2D(tokens, substring).setName(name));
				}
				substring = new StringBuffer(readElement(buffer, "Placemark"));
			}
		}
		else
		{
			// this file was generated by Google Earth, not by this software.
			// All that can be done is load the polygons into PolygonPoints objects.
			StringBuffer substring = new StringBuffer(readElement(buffer, "Polygon"));
			while (substring.length() > 0)
			{
				polygons.add(new PolygonPoints(parsePoints(readElement(substring, "coordinates"))));
				substring = new StringBuffer(readElement(buffer, "Polygon"));
			}
		}
		return polygons;
	}

	/**
	 * Write an array of polygons to a kml or kmz file.
	 * @param outputFile
	 * @param polygons
	 * @throws Exception
	 */
	public static void writeKMLZ(File outputFile, Polygon... polygons) throws Exception { 
		writeKMLZ(outputFile, Arrays.asList(polygons)); 
	}

	/**
	 * Write a list of polygons to a kml or kmz file.
	 * @param outputFile
	 * @param polygons
	 * @throws Exception
	 */
	public static void writeKMLZ(File outputFile, List<Polygon> polygons) throws Exception {

		// figure out the extension of the filename
		String fileExtension = "";
		int idx = outputFile.getName().lastIndexOf('.');
		if (idx > 0)
			fileExtension = outputFile.getName().substring(idx + 1);

		if (!fileExtension.equalsIgnoreCase("kml") && !fileExtension.equalsIgnoreCase("kmz"))
			throw new Exception("File extension must be one of 'kml' or 'kmz' but found "+fileExtension);

		if (outputFile.getName().toLowerCase().endsWith("kml"))
		{
			Writer output = new BufferedWriter(new FileWriter(outputFile));
			// call method to generate all the text to be written to kml file
			output.write(generateKmlzText(polygons, outputFile.getName()));
			output.close();
		}
		else if (outputFile.getName().toLowerCase().endsWith("kmz"))
		{
			FileOutputStream fos = new FileOutputStream(outputFile);
			ZipOutputStream zoS = new ZipOutputStream(fos);
			String name = outputFile.getName();
			name = name.substring(0, name.length()-1).concat("l");
			ZipEntry ze = new ZipEntry(name);
			zoS.putNextEntry(ze);
			PrintStream output = new PrintStream(zoS);          
			// call method to generate all the text to be written to kml file
			output.print(generateKmlzText(polygons, outputFile.getName()));
			zoS.closeEntry(); // close KML entry
			zoS.close();
		}
	}

	/**
	 * 
	 * @param tokens
	 * @param substring
	 * @return
	 * @throws Exception
	 */
	private static Polygon2D parsePolygon2D(String[] tokens, StringBuffer substring) throws Exception
	{
		if (tokens[0].equals("PolygonGlobal"))
			return new PolygonGlobal(tokens[1]);
		else if (tokens[0].equals("PolygonSmallCircles"))
			return new PolygonSmallCircles(tokens[1]);
		else if (tokens[0].equals("PolygonPoints"))
		{
			String[] ref = tokens[1].split("\\s+");
			return new PolygonPoints(parseLatLon(ref[1], ref[2]), ref[3].equals("in"), 
					parsePoints(readElement(substring, "coordinates")));
		}
		return null;
	}
	/**
	 * Given the text of a <coordinates> element, parse all the lat,lon,0 
	 * data and convert it into unit vectors.
	 * @param coordinates
	 * @return
	 */
	private static List<double[]> parsePoints(String coordinates)
	{
		String[] x = coordinates.trim().split("\\s+");
		List<double[]> points = new ArrayList<>(x.length);
		// each coordinate consists of lon,lat,0 
		for (int i=0; i<x.length; ++i)
		{
			String[] y = x[i].split(",");
			points.add(parseLatLon(y[1], y[0]));
		}
		return points;

	}

	/**
	 * Search the buffer for the specified element name.  Extract the element 
	 * from the buffer and return the extracted text. The buffer is modified by 
	 * removal of all text from the beginning of the buffer through the end of the requested element.
	 * @param buffer
	 * @param element
	 * @return
	 */
	private static String readElement(StringBuffer buffer, String element)
	{
		String result = "";
		int i=buffer.indexOf("<"+element+">");
		if (i >= 0)
		{
			int j = buffer.indexOf("</"+element+">", i);
			if (j > i)
			{
				result = buffer.substring(i+element.length()+2, j);
				buffer.delete(0, j+element.length()+3);
			}
		}
		return result;
	}

	/**
	 * Populate a String with the contents of an entire KML file.
	 * @param polygons
	 * @param name
	 * @return
	 */
	static private String generateKmlzText(List<Polygon> polygons, String name)
	{
		StringBuffer buf = new StringBuffer();
		buf.append("<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
		buf.append("<kml xmlns=\"http://www.opengis.net/kml/2.2\">\n");
		buf.append("<Document>\n");
		buf.append(String.format("<name>%s</name>%n", name));
		buf.append("<writtenby>gov.sandia.gmp.util.numerical.polygon.Polygon</writtenby>\n");
		buf.append("<open>0</open>\n");

		buf.append("<Style id=\"mystyle\">\n"
				+ "		<LineStyle>\n"
				+ "			<width>2</width>\n"
				+ "		</LineStyle>\n"
				+ "		<PolyStyle>\n"
				+ "			<color>80ffffff</color>\n"
				+ "		</PolyStyle>\n"
				+ "	</Style>\n"
				+ "	<StyleMap id=\"mystyle0\">\n"
				+ "		<Pair>\n"
				+ "			<key>normal</key>\n"
				+ "			<styleUrl>#mystyle</styleUrl>\n"
				+ "		</Pair>\n"
				+ "		<Pair>\n"
				+ "			<key>highlight</key>\n"
				+ "			<styleUrl>#mystyle1</styleUrl>\n"
				+ "		</Pair>\n"
				+ "	</StyleMap>\n"
				+ "	<Style id=\"mystyle1\">\n"
				+ "		<LineStyle>\n"
				+ "			<width>2</width>\n"
				+ "		</LineStyle>\n"
				+ "		<PolyStyle>\n"
				+ "			<color>80ffffff</color>\n"
				+ "		</PolyStyle>\n"
				+ "	</Style>\n"
				+ "");

		String start = 
				"<Placemark>%n"
						+"\t<index>%d</index>%n"
						+"\t<name>%s</name>%n"
						+"\t<description>%s</description>%n"
						+"\t<styleUrl>#mystyle</styleUrl>%n"
						+"\t<Polygon>%n";

		String end = "\t</Polygon>\n</Placemark>\n";


		int index = 0;
		for (Polygon polygon : polygons)
		{
			// if points.length is > 1 it means these points represent SmallCircle polygons and there 
			// could be many of them (one points[] array for each small circle.)
			// The small circles are output in order of decreasing radius (opposite of how they were
			// specified) so the even-indexed small circles must be written with outerBoundaryIs and 
			// odd indexed small circles must be written with innerBoundaryIs.
			double[][][] points = polygon.getPoints(true);
			for (int i=0; i<points.length; i+=2)
			{
				// write the 'Placemark' and 'Polygon' tags, including index, name, and description
				buf.append(String.format(start, index, polygon.getName(), kmlzString(polygon)));
				// write the polygon with 'outputBoundaryIs'
				buf.append(getKMLString(points[i], "outerBoundaryIs"));
				if (i < points.length-1)
					// write the polygon with 'innerBoundaryIs'
					buf.append(getKMLString(points[i+1], "innerBoundaryIs"));
				buf.append(end);
			}
			++index;
		}
		buf.append("</Document>\n");
		buf.append("</kml>\n");
		return buf.toString();
	}

	/**
	 * Write out the points surrounded by appropriate kml tags
	 * @param points
	 * @param side either "outerBoundaryIs" or "innerBoundaryIs"
	 * @return
	 */
	private static String getKMLString(double[][] points, String side) {
		return String.format("\t\t<%s>\n"
				+ "\t\t\t<LinearRing>\n"
				+ "\t\t\t\t<coordinates>\n"
				+ "\t\t\t\t\t%s\n"
				+ "\t\t\t\t</coordinates>\n"
				+ "\t\t\t</LinearRing>\n"
				+ "\t\t</%s>\n",
				side, pointsToCoordinates(points), side);
	}

	/**
	 * Write out all the points in one big long string in format for kml coordinates tag
	 * @param points
	 * @return
	 */
	private static String pointsToCoordinates(double[][] points) {
		StringBuffer buf = new StringBuffer();
		if (points.length > 0)
		{		
			double lonp = VectorGeo.getLonDegrees(points[0]);
			for (int i=0; i<points.length; ++i)
			{
				double lon = VectorGeo.getLonDegrees(points[i]);
				double lat = VectorGeo.getLatDegrees(points[i]);
				if (lon - lonp > 180) lon -= 360.;
				if (lon - lonp < -180) lon += 360.;
				lonp = lon;
				buf.append(String.format("%1.6f,%1.6f ", lon, lat));
			}
		}
		return buf.toString();
	}

	/**
	 * Retrieve  a description of a polygon:
	 * <ul>
	 * <li>PolygonGlobal;global in
	 * <li>PolygonSmallCircle;referencePoint lat lon in radius1 radius2 ...
	 * <li>PolygonPoints;referencePoint lat lon in
	 * <li>Polygon3D;TOP HorizonClass ...;BOTTOM HorizonClass ...;Polygon2DClass;one of the string above
	 * </ul>
	 * @param polygon
	 * @return
	 */
	private static String kmlzString(Polygon polygon)
	{
		String description = "";

		if (polygon instanceof PolygonGlobal)
			description = polygon.toString().replaceAll("\n", ";");
		else if (polygon instanceof PolygonSmallCircles)
			description = polygon.toString().replaceAll("\n", ";");
		else if (polygon instanceof PolygonPoints)
			description = polygon.getClass().getSimpleName()+";"+polygon.refPt();
		else if (polygon instanceof Polygon3D)
		{
			Polygon3D p3d = (Polygon3D)polygon;
			description = String.format("%s;TOP %s;BOTTOM %s;%s",
					polygon.getClass().getSimpleName(),
					p3d.getTop().toString(),
					p3d.getBottom().toString(),
					kmlzString(p3d.getPolygon2D())); //recursion!
		}
		return description;
	}

	/**
	 * Parse  lat, lon Strings in degrees into a unit vector
	 * @param lat
	 * @param lon
	 * @return
	 */
	private static double[] parseLatLon(String lat, String lon) {
		return VectorGeo.getVectorDegrees(Double.parseDouble(lat), Double.parseDouble(lon));
	}

}
